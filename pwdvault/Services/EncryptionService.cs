/*
Netsho - Implements AES encryption for passwords. 
Copyright (C) 2023-2024 Netsho

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
*/
using System.Security.Cryptography;
using System.Text;
using Konscious.Security.Cryptography;
using pwdvault.Services.Exceptions;
using Serilog;

namespace pwdvault.Services
{
    public static class EncryptionService
    {
        private const int SaltSize = 16; // 128 bit
        private const int HashSize = 16; // 128 bit
        private const int Iterations = 4; // Recommended minimum value
        private const int MemorySize = 512000; // 512 MB

        /// <summary>
        /// <para>
        /// Encrypts the password using AES256 encryption algorithm.
        /// The initialization vector is randomly generated by AES, and is returned.
        /// </para>
        /// </summary>
        /// <param name="password"></param>
        /// <param name="key"></param>
        /// <param name="iv"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        public static byte[] EncryptPassword(string password, byte[] key, out byte[] iv)
        {
            if (string.IsNullOrEmpty(password))
            {
                throw new ArgumentException("The password is empty.");
            }
            if (key is null || key.Length != 16)
            {
                throw new ArgumentException("The encryption key is either null or not a valid size.");
            }

            try
            {
                using var aes = Aes.Create();
                aes.Key = key;
                aes.GenerateIV();
                iv = aes.IV;

                var memoryStream = new MemoryStream();
                using (var cryptoStream = new CryptoStream(memoryStream, aes.CreateEncryptor(aes.Key, aes.IV), CryptoStreamMode.Write))
                {
                    var passwordBytes = Encoding.UTF8.GetBytes(password);
                    cryptoStream.Write(passwordBytes, 0, passwordBytes.Length);
                }
                return memoryStream.ToArray();
            }
            catch (Exception ex)
            {
                Log.Logger.Error(ex, "Source : {Source}, Message : {Message}\n {StackTrace}", ex.Source, ex.Message, ex.StackTrace);
                throw new PasswordException(ex.Message, ex);
            }
        }

        /// <summary>
        /// <para>
        /// Decrypts the encrypted password using AES256 decryption algorithm.
        /// </para>
        /// </summary>
        /// <param name="encryptedPassword"></param>
        /// <param name="key"></param>
        /// <param name="iv"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        public static string DecryptPassword(byte[] encryptedPassword, byte[] key, byte[] iv)
        {
            if (encryptedPassword == null || encryptedPassword.Length == 0)
            {
                throw new ArgumentException("The encrypted password is either null or empty.");
            }
            if (key is null || key.Length != 16)
            {
                throw new ArgumentException("The decryption key is either null or not a valid size.");
            }
            if (iv is null || iv.Length != 16)
            {
                throw new ArgumentException("The IV used to decrypt the password is either null or not a valid size.");
            }

            try
            {
                using var aes = Aes.Create();
                aes.Key = key;
                aes.IV = iv;

                using var memoryStream = new MemoryStream(encryptedPassword);
                using var cryptoStream = new CryptoStream(memoryStream, aes.CreateDecryptor(aes.Key, aes.IV), CryptoStreamMode.Read);
                using var msPlain = new MemoryStream();
                cryptoStream.CopyTo(msPlain);
                return Encoding.UTF8.GetString(msPlain.ToArray());
            }
            catch (Exception ex)
            {
                Log.Logger.Error(ex, "Source : {Source}, Message : {Message}\n {StackTrace}", ex.Source, ex.Message, ex.StackTrace);
                throw new PasswordException(ex.Message, ex);
            }
        }

        /// <summary>
        /// <para>
        /// Generates a new encrypting key to encrypt the password. The key generation is derived from the password.
        /// </para>
        /// </summary>
        /// <param name="password"></param>
        /// <returns></returns>
        public static byte[] GenerateKey(string password)
        {
            if (string.IsNullOrEmpty(password))
            {
                throw new ArgumentException("The password is empty.");
            }
            return GenerateHash(password);
        }

        /// <summary>
        /// Generates hash for user's password using Argon2id algorithm to minimize brute force and side channel attacks.
        /// The parameters affecting security and performance of Argon2id hash algorithm are number of parallelism, iterations and memory size.
        /// Degree of parallelism is equal to number of CPU Cores * 2, which is the specification of Argon2id.
        /// To know what iterations and memory size to use, benchmarking and testing needs to be done to get the amount of time used to compute the hash.
        /// The time used for the hashing should not be lower than 0,5 seconds and not greater than 5 seconds.
        /// </summary>
        /// <param name="password"></param>
        /// <returns></returns>
        private static byte[] GenerateHash(string password)
        {
            using var argon2Id = new Argon2id(Encoding.UTF8.GetBytes(password));
            argon2Id.Salt = GenerateSalt();
            // Number of CPU Cores x2
            argon2Id.DegreeOfParallelism = Environment.ProcessorCount * 2;
            argon2Id.Iterations = Iterations;
            argon2Id.MemorySize = MemorySize;
            return argon2Id.GetBytes(HashSize);
        }

        /// <summary>
        /// Generates 16 bytes salt for user's password.
        /// </summary>
        /// <returns></returns>
        private static byte[] GenerateSalt()
        {
            var salt = new byte[SaltSize];
            using var randomNumberGenerator = RandomNumberGenerator.Create();
            randomNumberGenerator.GetBytes(salt);
            return salt;
        }
    }
}
